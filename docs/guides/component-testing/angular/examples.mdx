---
title: Angular Examples
sidebar_position: 30
---

## Mounting Components

### Using `cy.mount()`

To mount a component with `cy.mount()`, import the component and pass it to the
method:

```ts
import { StepperComponent } from './stepper.component'

it('mounts', () => {
  cy.mount(StepperComponent)
})
```

### Passing Data to a Component

You can pass inputs and outputs to a component by setting
[componentProperties](/guides/component-testing/angular/api#MountConfig)
in the options:

```ts
cy.mount(StepperComponent, {
  componentProperties: {
    count: 100,
    change: new EventEmitter(),
  },
})
```

### Testing Event Handlers

Pass a Cypress [spy](/guides/guides/stubs-spies-and-clocks#Spies) to an event
prop and validate it was called:

```ts
it('clicking + fires a change event with the incremented value', () => {
  cy.mount(StepperComponent, {
    componentProperties: {
      change: createOutputSpy('changeSpy'),
    },
  })
  cy.get('[data-cy=increment]').click()
  cy.get('@changeSpy').should('have.been.calledWith', 1)
})
```

### Imports/Declarations/Providers

If you need to set up any additional `imports`, `declarations`, or `providers`
for your component to mount successfully, you can set them in the options
(similar to setting them up in `ngModule` in a app):

```ts
cy.mount(ComponentThatFetchesData, {
  imports: [HttpClientModule],
  declarations: [ButtonComponent],
  providers: [DataService],
})
```

See
[Default Declarations, Providers, or Imports](/guides/component-testing/angular/examples#Default-Declarations-Providers-or-Imports)
to set up common options in a custom `cy.mount()` command to avoid having to
repeat this boilerplate for each test.

### Using Standalone

Not only are [Standalone Components](https://angular.io/guide/standalone-components) supported, they are the simplest components to write tests for.
Standalone Components provide the Angular compiler with everything it needs to compile through its [`@Component()`](https://angular.io/api/core/Component) decorator.
This means that in most cases a Standalone Component can be mounted without ever providing any `imports`, `decorators`, or `providers`. Mounting then becomes as simple as:

```ts
cy.mount(MyStandaloneComponent)
```

### Using Angular Template Syntax

The `cy.mount()` method also supports the Angular template syntax when mounting
a component. Some developers might prefer this approach to the object based
mount style:

```ts
cy.mount(`<app-stepper [count]="100"></app-stepper>`, {
  declarations: [StepperComponent],
})
```

> When using template syntax, the component needs to added to the declarations
> in the options parameter.

Using with event emitter spy:

```ts
cy.mount('<app-button (click)="onClick.emit($event)">Click me</app-button>', {
  declarations: [ButtonComponent]
  componentProperties: {
    onClick: createOutputSpy('onClickSpy'),
  },
})
cy.get('button').click();
cy.get('@onClickSpy').should('have.been.called');
```

### Accessing the Component Instance

There might be times when you might want to access the component instance
directly in your tests. To do so, use `.then()`, which enables us to work with
the subject that was yielded from the `cy.mount()` command. In this case, mount
yields an object that contains the rendered component and the fixture.

In the below example, we use the component to spy directly on the `change` event
emitter.

```ts
it('clicking + fires a change event with the incremented value', () => {
  cy.mount(
    '<app-stepper count="100" (change)="change.emit($event)"></app-stepper>',
    {
      componentProperties: { change: new EventEmitter() },
      declarations: [StepperComponent],
    }
  ).then((wrapper) => {
    console.log({ wrapper })
    cy.spy(wrapper.component.change, 'emit').as('changeSpy')
    return cy.wrap(wrapper).as('angular')
  })
  cy.get(incrementSelector).click()
  cy.get('@changeSpy').should('have.been.calledWith', 101)
})
```

### Using createOutputSpy()

To make spying on event emitters easier, there is a utility function called
`createOutputSpy()` which can be used to automatically create an `EventEmitter`
and setup the spy on it's `.emit()` method. It can be used like the following:

```ts
import { createOutputSpy } from 'cypress/angular'

it('clicking + fires a change event with the incremented value', () => {
  // Arrange
  cy.mount('<app-stepper (change)="change.emit($event)"></app-stepper>', {
    declarations: [StepperComponent],
    componentProperties: {
      change: createOutputSpy<boolean>('changeSpy'),
    },
  })
  cy.get(incrementSelector).click()
  cy.get('@changeSpy').should('have.been.called')
})
```

### Using autoSpyOutputs

You might find yourself repeatedly creating a `cy.spy()` for each of your
component outputs. Because of this, we created an easy mechanism to handle this
for you. This feature can be turned on by passing the `autoSpyOutputs` flag into
`MountConfig`. After the component has been mounted you can then access each of
the generated spies using the `@Output()` property name + `Spy`. So our `change`
property can be accessed via its alias of `cy.get('@changeSpy')`

```ts
it('clicking + fires a change event with the incremented value', () => {
  cy.mount(StepperComponent, {
    autoSpyOutputs: true,
    componentProperties: {
      count: 100,
    },
  })
  cy.get(incrementSelector).click()
  cy.get('@changeSpy').should('have.been.calledWith', 101)
})
```

:::caution

The `autoSpyOutput` flag only works when passing in a component to the mount
function. It currently does not work with the template syntax.

:::

:::caution

`autoSpyOutput` is an **experimental feature** and could be removed or changed
in the future

:::

### Testing Signals

With the releases of Angular versions [17.1](https://github.com/angular/angular/blob/main/CHANGELOG.md#1710-2024-01-17) and [17.2](https://github.com/angular/angular/blob/main/CHANGELOG.md#1720-2024-02-14), [input](https://github.com/angular/angular/pull/53521) and [model](https://github.com/angular/angular/pull/54252) signals were introduced into the `@angular/core` API.
Since signals introduced new methods and types to the core API, Cypress needed to introduce a new test harness, `@cypress/angular-signals`, in order to support the API without breaking changes.

Though basic signals were introduced in Angular `16`, this testing harness requires Angular `17.2` and above.

For our below examples, we will be working with a very simple component called `TestComponent`, which looks something like this:

```typescript
// app/components/test-component.component.ts
import { Component, input, model } from '@angular/core'

@Component({
  selector: 'test-component',
  templateUrl: './test-component.component.html',
  standalone: true,
})
export class TestComponent {
  title = input.required<string>()
  count = model.required<number>()
}
```

```html
<!-- app/components/test-component.component.html -->
<p data-cy="test-component-title-display">{{ title() }}</p>
<p data-cy="test-component-count-display">{{ count() }}</p>
<button data-cy="test-component-count-incr" (click)="count.set(count() + 1)">
  Increase
</button>
<button data-cy="test-component-count-decr" (click)="count.set(count() - 1)">
  Decrease
</button>
```

#### Testing Input Signals

Having `input()` signals work outside the Angular injection context is a bit tricky. Input signals cannot be created outside the Angular injection context, nor is there a way to provide an injection context. Because of this, there are two ways to test `input()` signals with Cypress Component Testing.

##### Infered Generic Type

In the example below, the `title` prop being passed into our `TestComponent` is a generic type of the `input()` signal. In this example, that generic type is a `string`. Cypress wraps the generic value in a writable `signal()` and merges it into the prop. In other words:

```typescript
let titleProp = 'Test Component'
cy.mount(TestComponent, {
  componentProperties: {
    title: titleProp,
  },
})
```

Under the hood in the `@cypress/angular-signals` test harness is really:

```typescript
cy.mount(TestComponent, {
  componentProperties: {
    title: signal('Test Component'),
  },
})
```

##### Writable Signal

Since the infered generic type in our example above lives outside the Angular context, there is no way for Cypress to enforce the one-way databinding on context updates. In other words, updates to the `titleProp` variable will not update the prop being passed into `TestComponent`.

To solve this problem, Cypress allows users to pass a writable `signal()` wrapped in the generic type as the prop. This allows us to test our one-way databinding.

```typescript
const myTitlePropAsSignal = signal('Test Component')
cy.mount(TestComponent, {
  componentProperties: {
    title: myTitlePropAsSignal,
  },
})

cy.get('the-title-element').should('have.text', 'Test Component')
cy.then(() => {
  // now set the input() through a signal to update the one-way binding
  myTitlePropAsSignal.set('FooBar')
})

cy.get('the-title-element').should('have.text', 'FooBar')
```

###### Change spy for signal `input()`

Since the prop in question is an `input()`, Cypress does not propagate changes to the `titleChange` spy.

```typescript
cy.mount(TestComponent, {
  componentProperties: {
    title: 'Test Component',
    // @ts-expect-error
    titleChange: createOutputSpy('titleChange'),
  },
})

// some action that changes the title prop...

// this assertion will not be true. Cypress will never emit change events for props that are `input()` signals
cy.get('@titleChange').should('have.been.called')
```

#### Testing Model Signals

`model()` signals are writable signals, meaning they have the ability to support two-way data binding.

##### Infered Generic Type

In the example below, the `count` prop being passed into our `TestComponent` is the generic type of the `model()` signal. In this example, that generic type is a `number`. Cypress sets the generic value in the writable `model()`.

```ts
cy.mount(TestComponent, {
  componentProperties: {
    count: 1,
  },
})

cy.get('the-count-element').should('have.text', '1')
```

##### Writable Signal

Since the infered generic type in our example above lives outside the Angular context, there is no way for Cypress to enforce the databinding on context updates. In other words, updates to the `count` variable will not update the prop being passed into `TestComponent`. This is incredibly similar to how infered generic types of `input()` signals work.

To solve this problem, Cypress allows users to pass a writable `signal()` wrapped in the generic type as the prop. Since this is a `model()` signal, this allows us to test two-way databinding.

```typescript
let count = signal(5)
cy.mount(TestComponent, {
  componentProperties: {
    count,
  },
})

// some action that changes the count to 7 inside the component

cy.then(() => {
  // this assertion will be true
  expect(count()).to.be(7)
})
```

```typescript
let count = signal(5)
cy.mount(TestComponentComponent, {
  componentProperties: {
    count,
  },
})

cy.then(() => {
  count.set(8)
})

// this assertion will be true
cy.get('the-count-element').should('have.text', '8')

// later in the test, some action that changes the count to 14 inside the component
// this assertion will be true
cy.get('the-count-element').should('have.text', '14')
```

##### Change spy for models

Since the prop in question is an `model()` and is a `WritableSignal`, Cypress **will** propagate changes to `countChange` if the output spy is created, either like the example below or if `autoSpyOutputs: true` is configured. However, the typing for `countChange` are not supported since this is technically not a prop (`@Output()` actually adds this as a prop which is not true in our case, even though the signal output is completely valid).

If created, this spy will emit changes anytime the model changes. This includes updates in the two-way binding context.

```typescript
cy.mount(TestComponent, {
  componentProperties: {
    count: 4,
    // @ts-expect-error
    countChange: createOutputSpy('countChange'),
  },
})

// some action that changes the count...

// this assertion will be true
cy.get('@countChange').should('have.been.called')
```

## Custom Mount Commands

### Customizing `cy.mount()`

By default, `cy.mount()` is a simple passthrough to `mount()`, however, you can
customize `cy.mount()` to fit your needs. For instance, you may find yourself
doing repetitive work during mounting. In order to reduce boilerplate you may
find it useful to create a custom mount command.

### Default Declarations, Providers, or Imports

If you find yourself registering a bunch of declarations, providers, or imports
in your individual tests, we recommend doing them all within a custom
`cy.mount()` command. The overhead is usually minimal for all your tests and it
helps keep your spec code clean.

Below is a sample that registers several default component declarations while
still allowing additional ones to be passed in via the config param. The same
pattern can also be applied to providers and module imports.

```ts title=support/component.ts
import { Type } from '@angular/core'
import { mount, MountConfig } from 'cypress/angular'
import { ButtonComponent } from 'src/app/button/button.component'
import { CardComponent } from 'src/app/card/card.component'

declare global {
  namespace Cypress {
    interface Chainable {
      mount: typeof customMount
    }
  }
}

const declarations = [ButtonComponent, CardComponent]

function customMount<T>(component: string | Type<T>, config?: MountConfig<T>) {
  if (!config) {
    config = { declarations }
  } else {
    config.declarations = [...(config?.declarations || []), ...declarations]
  }
  return mount<T>(component, config)
}

Cypress.Commands.add('mount', customMount)
```

This custom mount command will allow you to skip manually passing in the
`ButtonComponent` and `CardComponent` as declarations into each `cy.mount()`
call.

### autoSpyOutputs

Here is an example of defaulting `autoSpyOutputs` for every mounted component:

```ts title=support/component.ts
declare global {
  namespace Cypress {
    interface Chainable {
      mount: typeof mount
    }
  }
}

Cypress.Commands.add(
  'mount',
  (component: Type<unknown> | string, config: MountConfig<T>) => {
    return mount(component, {
      ...config,
      autoSpyOutputs: true,
    })
  }
)
```

:::caution

The `autoSpyOutput` flag only works when passing in a component to the mount
function. It currently does not work with the template syntax.

:::
