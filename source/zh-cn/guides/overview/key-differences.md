---
title: 我们的优势
---

{% note info %}
# {% fa fa-graduation-cap %} 通过这篇文档你将会学习到

- 是什么造就了Cypress的与众不同
- 它与Selenium架构上有何区别
- 完成以前不可达到的全新的测试处理办法和理念

{% endnote %}

# 架构

大多数测试工具（如Selenium）通过在浏览器外部运行并在网络上执行远程命令来运行。*Cypress恰恰相反。*Cypress在与你的应用程序相同的生命周期里执行。

Cypress背后是Node服务进程。 Cypress和Node进程不断进行通信，同步和执行任务。 访问这两个部分（前端和后端）使我们能够实时响应你的web应用程序的事件，与此同时在浏览器之外也能工作以完成需要更高权限的任务。

Cypress还可以通过即时读取和更改网络流量工作在网络(请求)层。 这使得Cypress不仅可以修改进出浏览器的所有内容，还可以更改可能会影响自动化浏览器操作的代码。

Cypress从根本上自上而下地控制整个自动化的流程，这使得它具备清楚进出浏览器发生的所有事情，这也意味着它相对于其他测试工具可以提供稳定性更加可靠的结果。

因为Cypress是本地{% url "安装" installing-cypress %}的, 它可以从系统层提供对自动化任务的服务. 也就是说，比如{% url "截图或录屏" screenshots-and-videos %}, 一般的{% url "命令执行" exec %}和{% url "请求" request %}成为可能.

# 源生权限

因为Cypress是在应用的内部进行操作，所以它对任何一个对象都具有源生的访问权限。不管是`window`、`document`、一个DOM元素、你的web应用实例、一个函数、一个计时器(timer)、一个服务或者任何其他的东西，你都有权限进行访问。对于Cypress来说，不需要对象序列化，不需要线上协议 - 你可以访问所有内容。你的测试代码可以访问任何只要是你应用能访问的东西。

# 新理念

对应用程序、网络请求/流量以及主机系统的最终控制权解锁了以前从未有过的全新测试。不再像旧的测试，被堵在应用之外，而且控制起来不那么容易 - Cypress让你有具备修改应用如何工作的任何能力；不再像旧测试代价高昂而且缓慢，比如创建一个指定的状态或前提条件之类，你可以轻而易举自然地创建这些状态就像在做单元测试一样。比如，你可以：

- {% url "存根" stub %}你的浏览器或应用的方法，强制它们做出你测试用例需要的表现。
- 显式化数据存储(比如Redux——JavaScript状态容器，提供可预测化的状态管理)以便你能通过测试代码程序直接修改应用的状态信息。
- 边缘测试用例等可以通过强制让服务器返回一个空的响应来完成，比如对空结果的测试等。
- 通过{% url "修改响应状态码为500" route %}测试你的应用如何对错误做出响应的。
- 直接修改DOM元素 - 比如强制某些隐藏的元素显示出来。
- 代码化地使用第三方'插件'程序。 不再需要烦躁地使用复杂的UI控件，比如多选，自动填充，下拉，树形视图或者日历等，你可以直接从测试代码中调用方法来完成控制操作。
- 测试时，还能{% url "在你的应用本身的任何代码运行*之前*，阻止Google分析加载" configuration#blacklistHosts %}。
- 不管是应用在过渡到新页面还是卸载时都能同步获取到通知消息。
- {% url "控制时间前进或后退" clock %}以便计时器马上跳到指定时刻或其他必须到某个时间才能触发的事件可以马上发生。
- 还可以添加自定义的应用事件监听器。 在Cypress里，你可以更新应用代码以表现为测试所期望的行为。你可以控制比如WebSocket的消息，条件化地加载第三方脚本，直接调用应用方法函数等。

# 一点简述

绞尽脑汁地测试你的应用领域？ 不喜欢某些操作制造出来的副作用？ 厌倦了一遍又一遍地重复同样的、缓慢的操作？ 现在，你可以在大多数测试用例中跳过它们。

Cypress阻止你被迫总是"像用户一样"来生成给定情况的状态。 使用Cypress，你可以通过编程方式交互和控制应用程序。 你不再需要使用UI来构建状态。

这意味着你不必访问登录页面，输入用户名和密码，并等待页面加载和/或重定向到你运行的每个测试。 Cypress让你能够快捷方式并以编程方式登录。使用类似{% url `cy.request()` request %}的命令, 你可以直接发送HTTP请求，且让这些请求的响应同步到浏览器。 Cookie会自动发送并应用。 担心CORS(跨域资源共享问题)？ 不用的，它是完全被绕过的。 选择何时像用户一样进行测试以及何时跳过缓慢和重复的部分的权力是你的。

# 防碎片专家

Cypress同步了解并理解应用程序中发生的所有事情。 它知道页面加载时到页面卸载的任何时刻发生的任何事情。 Cypress在发生事件时不可能错过元素。 它甚至知道元素动画的速度有多快，并且会{% url "等待动画渲染" interacting-with-elements#Animations %}直至对特定网络请求完成。此外，它会{% url "自动等待元素" interacting-with-elements#Visibility %}在特定网络请求上完成后直至{% url "显示出来" interacting-with-elements#Disability %}， {% url "揭开被覆盖的元素" interacting-with-elements#Covering %}等。当页面间开始过渡时，Cypress会自动暂停执行直至后一个页面完全加载完成。你甚至可以让Cypress{% url "等待" wait %}直至某些特定的请求完成。

Cypress在浏览器中执行绝大多数命令，因此没有网络延迟。 命令以尽可能快的速度执行、驱动你的应用程序。 要处理具有复杂UI的现代JavaScript框架，你可以使用断言告诉Cypress你的应用程序应该处于什么状态。 在继续下一步之前，Cypress会自动等待你的应用程序达到此状态。 通过手动等待或重试，你可以完全避免烦恼。 赛普拉斯会自动等待元素直至存在，并且永远不会产生与DOM分离的陈旧元素。

# 可调式能力

最重要的是Cypress是为了实用性而建造的。

有数百条自定义错误消息描述Cypress未通过测试的确切原因。

有一个丰富的UI，可以直观地显示命令执行，断言，网络请求，侦探(spies)，存根(stub)，页面加载或URL更改。

Cypress为你的应用程序拍摄截图，使你能够时间回到命令运行时的状态。

你可以在测试运行时使用开发者工具，你可以看到每个控制台消息，每个网络请求。 你可以检查元素，甚至可以在规范代码或应用程序代码中使用调试器语句。 不会有信息丢失 - 你可以使用你已经熟悉的所有工具。 这使你可以同时测试和开发所有内容。

# 一些折衷

虽然Cypress有许多新的强大功能，但我们在实现这一目标方面也做出了重要的权衡。

如果你有兴趣了解更多信息，我们已经就此主题编写了完整的指南。
