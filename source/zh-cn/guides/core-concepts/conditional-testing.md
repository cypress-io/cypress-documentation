---
title: 条件测试
---

{% note info %}
# {% fa fa-graduation-cap %} 通过这篇文档你将会学习到

- 条件测试时你测试的一个很好的选择
- 无法进行条件测试的情况
- 处理条件测试常见场景的策略
{% endnote %}

# 定义

条件测试是指常见的编程模式：

> If X, then Y, else Z

我们许多用户都在询问如何在Cypress完成这个看似简单的常规用法。

以下是一些示例：

- 无论元素是否存在，我该如何做一些不同的事情？
- 我的应用程序做 A/B测试，我该如何解释？
- 我的用户收到"欢迎向导"，但是现有用户没有。我是否可以随时关闭向导，如果没有显示，请忽略它。
- 我可以从Cypress失败的命令中恢复测试程序么？例如 {% url "`cy.get()`" get %} 找不到元素。
- 我正在尝试编写动态测试，根据页面上的文本执行不同的操作。
- 我想自动找到所有 `<a>` 元素，根据我找到的元素，我想检查每个链接是否有效。

问题是 - 虽然上面的情况看起来很简单，但是以这种方式编写测试通常会导致测试不稳定，随机失败以及难以追踪边缘情况。

让我们来研究为什么以及如何克服这些问题...

# 问题

现代JavaScript应用程序具有高度动态性和可变性。他们的状态和DOM在一段时间内不断变化。

**条件测试**的问题是它只能在状态稳定时使用。在现代应用中，了解状态何时稳定通常是不可能的。

对于一个人 - 我们假设状态总是相同的，如果事情从现在开始变化10毫秒或100毫秒，我们甚至可能不会注意到这种变化。

对于一个机器人 - 这10毫秒甚至代表了十亿多的时钟周期。时间尺度差异令人难以置信。

人类还有直觉。如果单击一个按钮并看到加载一个加载中的图片，那么你将假设该状态处于不稳定状态并将自动等待它完成。

机器人没有直觉 - 它将完全按照程序设计来执行。

为了说明这点，让我们列举一个非常简单的例子来尝试有条件的测试不稳定状态。

## DOM不稳定

```js
// 你的应用程序代码

// 随机的时间
const random = Math.random() * 100

// 创建一个 <button> 元素
const btn = document.createElement('button')

// 把它附加到body元素上
document.body.appendChild(btn)

setTimeout(() => {
  // 在不确定的时间后把该按钮的class属性设置为active
  btn.setAttribute('class', 'active')
}, random)
```

```js
// 你的Cypress测试代码
it('does something different based on the class of the button', function () {
  // 尝试重复执行这个测试
  // 你将会发现这个测试有时候能通过测试
  // 但是有时候却是不能通过测试

  cy.get('button').then(($btn) => {
    if ($btn.hasClass('active')) {
      // 如果它是active我们做其它事情
    } else {
      // 做其它事情
    }
  })
})
```

你能看到这个问题吗？这个测试是不确定的。`<button>`有时候会有 `active` 而有时候又没有。在**大多数**情况下，你不能依赖DOM的状态来确定你应该有条件的做什么。

这就是片状测试的核心。在Cypress中，我们在设计API的时候就确保了每一步都能抵御这种类型的情况。

# 目前的情况

对DOM进行条件测试的**唯一**方法是，如果你100%确定状态已经"稳定"并且没有可能的方式进行更改。

这就对了！在任何其他情况下，如果你尝试依赖DOM的状态进行条件测试，则会出现片状测试。

我们来看几个例子。

## 服务端渲染

如果你的应用程序是服务端渲染的并且没有JavaScript进行异步修改DOM - 祝贺你，你可以轻松地对DOM进行条件测试！

为什么？因为如果在`load`事件发生后DOM不会改变，那么它可以准确的表示稳定的真实状态。

你可以安全的直接跳到我们提供条件示例部分。

## 客户端渲染

但是，在大多数现代应用程序中 - 当`load`事件发生时，屏幕上通常没有呈现任何内容。 通常在此时你的脚本开始加载动态内容并异步来呈现页面。

不幸的是，在这种情况下你无法使用DOM进行条件测试。要做到这一点，你需要100%保证你的应用程序已经完成所有异步操作，并且没有待处理的网络请求、setTimeouts、interval、postMessage或async/await代码。

如果你不对应用程序进行更改，这很难处理（不是不可能）。你可以使用像{% url "Zone.js" https://github.com/angular/zone.js/ %}这样的库，但即使这样也不能保证捕获每个异步请求。

换句话说，如果你希望测试始终100%运行，则无法安全的进行条件测试。

但不要担心 - 有更好的解决方法仍然可以实现条件测试**而不依赖**DOM。你只需要自己*设置*另一条不变的真理即可。

# 策略

如果你无法保证DOM是稳定的 - 请不要担心，还有其它方法可以进行条件测试或解决固有问题。

**你可以：**

- 移除需要进行条件测试的代码。
- 强制你的应用程序以确定的方式运行。
- 检查其它来源的准确性（例如你的服务器或数据库）。
- 将数据嵌入到你可以读到的其它地方（Cookies/local storage）。
- 将数据添加到DOM中你可以读取得到的地方。

让我们探讨一些条件测试的例子，它们会100%的成功或失败。

## A/B 广告

在此示例中，假设你访问了你的网站，并且服务器会根据你的信息来决定给你发送A/B广告。它获取是基于地理位置，IP地址，时间，地点或其它难以控制的因素。那么你怎么来写测试？

简单的：控制发送哪一个广告，或者提供一个可靠的方式来知道需要发送哪一个。

### 使用URL查询参数：

```js
// 告诉你的服务器你需要发送哪个广告
// 这样你就可以确定的知道它是什么了
cy.visit('https://app.com?campaign=A')

...

cy.visit('https://app.com?campaign=B')

...

cy.visit('https://app.com?campaign=C')
```

现在你甚至不需要进行条件测试了，因为你可以提前知道发送了哪个广告。这可能需要服务端配合修改，但是如果你想测试它，你必须让一个本来不可测试的变为可测试。

### 使用服务端：

或者，如果你的服务器使用session来保存广告信息，你可以让服务器告诉你使用哪个广告。

```js
// 这会向我们发送session cookies
cy.visit('https://app.com')

// 假设这会把广告信息送给我们
cy.request('https://app.com/me')
  .its('body.campaign')
  .then((campaign) => {
    // 根据不同的广告
    // 来执行不同的Cypress测试代码
    return campaigns.test(campaign)
  })
```

### 使用session cookies:

也许更简单的测试方法是：你的服务器在session cookie中发送你可以读的广告信息。

```js
cy.visit('https://app.com')
cy.getCookie('campaign')
  .then((campaign) => {
    return campaigns.test(campaign)
  })
```

### 在DOM中嵌入数据：

另一个有效的策略是将数据直接嵌入到DOM中 - 但这样做的方式是数据**总是**存在并且可以查询。它必须在100%的时间内出现，否则这不起作用。

```js
cy.get('html')
  .should('have.attr', 'data-campaign').then((campaign) => {
    return campaigns.test(campaign)
  })
```

## 欢迎向导

在这个例子中，我们假设你正在运行一堆测试，每次加载应用程序时，它都可能进入"欢迎向导"模式。

在这种情况下，你希望在存在时关闭向导，如果不存在则忽略它。

这样做的问题是，如果欢迎向导是异步渲染（可能会这样做），则无法使用DOM有条件的关闭它。

再一次 - 我们需要另一种可靠的方式来实现这一目标而不涉及DOM。

这个模式与之前几乎相同：

### Use the URL to control it:

```js
// 不要显示向导
cy.visit('https://app.com?wizard=0')
```

```js
// 显示向导
cy.visit('https://app.com?wizard=1')
```

我们只需要更新客户端代码来检查这个查询参数是否存在。现在我们提前知道它是否会被显示出来。

### 使用Cookies来提前知道：

如果你无法控制它，但仍然可以有条件的处理它**如果**你知道他是否会被显示。

```js
cy.visit('https://app.com')
cy.getCookie('showWizard')
  .then((val) => {
    if (val) {
      // 通过三个额外的命令
      // 来有条件的关闭向导
      cy.get('#wizard').contains('Close').click()
    }
  })
  .get(...)    // 更多的命令
  .should(...) // 更多的命令
  .click()     // 更多的命令
```

### 使用你的服务器或数据库：

如果服务器存储了是否需要显示向导，那么直接问它就行了。

```js
cy.visit('https://app.com')
cy.request('https://app.com/me')
  .its('body.showWizard')
  .then((val) => {
    if (val) {
      // 通过三个额外的命令
      // 来有条件的关闭向导
      cy.get('#wizard').contains('Close').click()
    }
  })
  .get(...)    // 更多的命令
  .should(...) // 更多的命令
  .click()     // 更多的命令
```

或者，如果你正在创建用户，则可以更容易的设置是否希望提前显示向导。这样可以避免后续的检查。

### 在DOM中嵌入数据

另一个有效的策略是将数据直接嵌入到DOM中 - 但这样做的方式是数据**总是**存在并且可以查询。它必须在100%的时间内出现，否则这不起作用。

```js
cy.get('html').should('have.attr', 'data-wizard').then((wizard) => {
  if (wizard) {
    // 通过三个额外的命令
    // 来有条件的关闭向导
    cy.get('#wizard').contains('Close').click()
  }
})
.get(...)    // 更多的命令
.should(...) // 更多的命令
.click()     // 更多的命令
```

## 元素存在

在你**试图**使用DOM进行条件测试的情况下，你可以利用同步查询Cypress中的元素来控制流程。

{% note warning %}
如果你没有看到上面的内容并直接跳到这里，我们将再次申明：

你不能对DOM进行条件测试，除非你是：

- 没有异步JavaScript的服务端渲染。
- **仅**使用同步渲染的客户端JavaScript。

了解应用程序的工作原理至关重要，否则你将编写不稳定的测试。
{% endnote %}

让我们假设我们有一个场景。我们的应用程序可能会做两件我们无法控制的事情。换句话说，你尝试了上述每个策略，无论出于何种原因，你无法提前知道应用程序将执行的操作。

可以在Cypress中进行测试。

```js
// 应用代码
$('button').on('click', (e) => {
  // 随机同步做一些事情
  if (Math.random() < .5) {
    // 添加一个input框
    $('<input />').appendTo($('body'))
  } else {
    // 或者添加一个textarea
    $('<textarea />').appendTo($('body'))
  }
})
```

```js
// 单击按钮会新添加一个元素
cy.get('button').click()
cy.get('body').then(($body) => {
  // 从body中同步查询
  // 找到新创建的元素
  if ($body.find('input').length) {
    // input被找到，执行其它的操作
    return 'input'
  }

  // 否则假设它是textarea
  return 'textarea'
})
  .then((selector) => {
    // selector表示一串字符串
    // 我们可以用来找到它的选择器
    cy.get(selector).type(`found the element by selector ${selector}`)
  })
```

我们将再重申一次。如果`<input>`或者`<textarea>`是异步渲染的，则无法使用上面的模式。你将不得不设置一个任意时间的延迟，这种延迟在每种情况下都不会起作用，相反还会减慢你的测试速度，并且仍然会让你的测试不稳定（这是一种完全的反模式）。

Cypress致力于创造**可靠的测试**。编写良好测试的秘诀是向Cypress提供尽可能多的"状态"和"事实，并"保护"它发出新命令，直到你的应用程序达到所需的状态为止。

进行条件测试会带来一个巨大的问题 - 测试编写者自己不确定给定的状态是什么。在这些情况下，进行准确测试的唯一可靠方法是以可靠和一致的方式嵌入此动态状态。

如果你不确定狮子是否编写了一个可能不稳定的测试，那么可以通过一种简单的方法来解决这个问题。重复测试多次，然后通过修改开发人员工具来限制网络和CPU。这将模拟不同环境（例如CI）的不同负载。如果你写了一个好的测试，它将100%的通过或失败。

```js
Cypress._.times(100, (i) => {
  it(`num ${i + 1} - test the thing conditionally`, () => {
    // 做100次条件测试
  })
})
```

## 动态文本

根据是否存在某些文本来有条件的做某些事情的模式与上面的元素的例子存在一些相似点。

### 有条件的检查元素是否有某些文本：

```js
// 这只有在100%保证的情况下才有效
// body已经完全显示，没有任何还在对状态进行的修改
cy.get('body').then(($body) => {
    // 同步查询body中的文字
    // 并根据它是否包含指定字符串来做一些事
    if ($body.text().includes('some string')) {
      // 找到了
      cy.get(...).should(...)
    } else {
      // 没找到
      cy.get(...).should(...)
    }
  })
```

# 错误恢复

我们许多用户都会问如何从失败的命令中恢复。

> 如果我有错误处理，我可以尝试找到X，如果X失败，则取找Y。

因为错误处理在大多数编程语言中是常见的用法，特别是在Node中，所以在Cypress中期望这样做似乎是合理的。

然而，这与要求进行条件测试的问题完全相同，只是稍微不同的实现细节。

例如，你可能想要这样做：

**以下代码无效，你无法在Cypress命令中添加错误处理。该代码仅用于演示。**

```js
cy.get('button').contains('hello')
  .catch((err) => {
    // 哦这个按钮没有找到
    // （或者其它事情失败了）
    cy.get('somethingElse').click()
  })
```

如果你是从头开始一直读到这里，那么你应该已经知道了为什么尝试使用异步渲染来实现条件代码并不是一个好主意。如果测试编写者无法准确预测系统的给定状态，那么Cypress也无法做到。错误处理不提供额外的证据，这可以确定性的完成。

你应该将Cypress中的失败命令视为类似于服务端代码中未捕获的异常。由于系统已经转为不可靠状态，因此无法尝试在这些情况下进行恢复。相反你通常总是选择崩溃和日志。当Cypress未通过测试时 - 这正是它正在做的事情。跳过测试中的任何剩余命令并记录失败的日志。

但是...为了争论，让我们想象一下你崽Cypress中做过错误处理。

有了错误处理后就意味着对于每个单个命令，它将从错误中恢复，但仅在达到每个适用的命令的超时时间之后。由于超时从4秒开始（并且超过这个时间），这意味着它只会在很长很长时间后失败。

让我们重新构想上面的"欢迎向导"示例。

**以下代码无效，你无法在Cypress命令中添加错误处理。该代码仅用于演示。**

```js
// 很棒的错误恢复代码
function keepCalmAndCarryOn () {
  cy.get(...).should(...).click()
}

cy
  .get('#wizard').contains('Close').click()
  .catch((err) => {
    // 没问题，我猜这个向导不存在
    // 或者其它的...不用担心
    keepCalmAndCarryOn()
  })
  .then(keepCalmAndCarryOn)
```

**最好**的情况下，在我们出错并继续之前可能我们浪费了至少4s来等待`<#wizard>`元素。

但是在**最糟糕**的情况下，我们遇到的情况是`<#wizard>`将被渲染，但它在我们给定的超时时间内没有渲染。我们假设这是由于挂起的网络请求或WebSocket消息或排队的计时器或其它任何原因造成的。

在这种情况下，我们不仅要等待很长一段时间，而且当最终显示 `<#wizard>` 元素时，它可能会在其它命令的下游引起错误。

如果你无法准确了解应用程序的状态，那么无论你使用哪种编程用法 - **你都无法编写100%确定的测试**。

还是不相信？

这不仅是一种反模式，而且是一种真正的逻辑谬误。

你可能会想到自己... 好吧，但4秒钟 - 男人还不够。网络请求可能很慢，让我们把它提升到1分钟！

即便如此，仍然可能有一个WebSocket消息进来... 所以5分钟！

即时这样，还不够，setTimeout可能会触发... 60分钟。

不断提高超时时间只会让人感到困惑。当你的超时时间接近无限时，你的信心会继续上升，因为你知道它将会达到预期的状态，但你永远无法证明它会。相反，你理论上可以等待宇宙的热量死亡，因为即将到来的情况发生在一瞬间。没有办法证明或反驳它*可能*有条件的发生。

你，测试编写者必须提前知道你的应用程序要做什么 - 或者100%确定可变对象（如DOM）的状态已经稳定以便编写准确的条件测试。
